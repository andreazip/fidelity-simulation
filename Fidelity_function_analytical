import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.optimize import differential_evolution

# ----------------------------------------
# Fidelity functions
# ----------------------------------------
def F_n_z(epsilon1, epsilon2):
    return (np.cos(epsilon2) * np.cos(epsilon1) - 0.5 * np.sin(epsilon2) * np.sin(epsilon1))**2

def F_x_z(epsilon1, epsilon2):
    return (np.cos(epsilon1) * np.cos(epsilon2))**2

def F_x_x(epsilon1, epsilon2):
    return (np.cos(epsilon1+epsilon2))**2

def F(theta2, epsilon1, epsilon2, epsilon3):
    delta_epsilon = epsilon1 - epsilon3
    epsilon_tot = epsilon3 + epsilon1

    term1 = (3/4) * np.sin(theta2/2) * np.sin(theta2/2 + epsilon2) * np.cos(delta_epsilon)
    term2 = (np.cos(theta2/2) * np.cos(theta2/2 + epsilon2) + (1/4) * np.sin(theta2/2) * np.sin(theta2/2 + epsilon2)) * np.cos(epsilon_tot)
    term3 = 0.5 * np.sin(epsilon2) * np.sin(epsilon_tot)

    return (term1 + term2 + term3)**2

def F_x_x_x(epsilon1, epsilon2, epsilon3):
    return (np.cos(epsilon1+epsilon2+epsilon3))**2

# ----------------------------------------
# Compute grid for any function
# ----------------------------------------
def compute_grid(func, theta2=None, eps1_range=(-0.1,0.1), eps2_range=(-0.1,0.1), eps3_range=(-0.1,0.1), resolution=200):
    eps1 = np.linspace(*eps1_range, resolution)
    eps2 = np.linspace(*eps2_range, resolution)
    eps3 = np.linspace(*eps3_range, resolution)
    E1, E2, E3 = np.meshgrid(eps1, eps2, eps3, indexing='ij')

    if theta2 is not None:
        Z = func(theta2, E1, E2, E3)
    else:
        Z = func(E1, E2)  # for 2D fidelities

    return E1, E2, E3, Z

# ----------------------------------------
# 3D surface plotting
# ----------------------------------------
def plot_surface_3d(E1, E2, Z, xlabel="ε1", ylabel="ε2", zlabel="Fidelity", title="Fidelity Surface"):
    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(E1, E2, np.log10(1-Z), cmap='viridis')
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    ax.set_zlabel(zlabel)
    ax.set_title(title)
    

# ----------------------------------------
# Heatmap plotting
# ----------------------------------------
def plot_heatmap(E1, E2, Z, xlabel="ε1", ylabel="ε2", title="Fidelity Heatmap"):
    Z = Z.copy()
    # Compute infidelity
    inf = 1 - Z
    # Find smallest positive infidelity
    nz_min = np.min(inf[inf > 0])
    # Replace zeros in INFIDELITY
    inf[inf == 0] = nz_min
    plt.figure(figsize=(6,5))
    Z_plot = np.log10(inf)  # log of infidelity
    im = plt.imshow(Z_plot, extent=[E1.min(), E1.max(), E2.min(), E2.max()],
                    origin='lower', cmap='viridis', aspect='auto')
    plt.colorbar(im, label='Infidelity')
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    
# ----------------------------------------
# Heatmap plotting for different
# ----------------------------------------
def plot_heatmaps_theta2(theta_list, E1, E2, E3, fixed_3 =True,  xlabel="ε1", ylabel="ε2", title="Infidelity Heatmap for different $\\theta$"):
    fig, axes = plt.subplots(1, len(theta_list), figsize=(5*len(theta_list), 4))

    for ax, theta2 in zip(axes, theta_list):
        Z = 1 - F(theta2, E1, E2, E3)
        if fixed_3:
            im = ax.pcolormesh(E1, E2, np.log10(Z), shading='auto')
            ax.set_title(f"θ₂ = {theta2:.2f}")
            ax.set_xlabel("ε1")
            ax.set_ylabel("ε2")
        else:
            im = ax.pcolormesh(E1, E3, np.log10(Z), shading='auto')
            ax.set_title(f"θ₂ = {theta2:.2f}")
            ax.set_xlabel("ε1")
            ax.set_ylabel("ε3")

    fig.colorbar(im, ax=axes.ravel().tolist(), label="1 - F")
    # Add a figure-wide title
    fig.suptitle(title, fontsize=16)

    #plt.show()

def plot_heatmap_theta_vs_epsilon(theta_range, epsilon_range, resolution_theta=100, resolution_eps=100):
    """
    Plot a heatmap of fidelity (or infidelity) as a function of theta2 and epsilon,
    assuming all epsilon errors are equal (eps1 = eps2 = eps3 = eps).
    
    Parameters
    ----------
    theta_range : tuple
        (theta_min, theta_max) in radians
    epsilon_range : tuple
        (epsilon_min, epsilon_max) in radians
    resolution_theta : int
        Number of points along theta2 axis
    resolution_eps : int
        Number of points along epsilon axis
    log_scale : bool
        If True, plot log10(1-F); else plot 1-F
    """
    theta_vals = np.linspace(*theta_range, resolution_theta)
    eps_vals = np.linspace(*epsilon_range, resolution_eps)

    # Create meshgrid
    THETA, EPS = np.meshgrid(theta_vals, eps_vals, indexing='ij')

    # Compute fidelity
    F_vals = F(THETA, EPS, EPS, EPS)   # all eps equal
    # Compute log-infidelity safely
    Z = np.log10(np.clip(1 - F_vals, 1e-15, None))
        
    # Plot heatmap
    plt.figure(figsize=(6,5))
    im = plt.pcolormesh(EPS, THETA, Z, shading='auto', cmap='viridis')
    plt.colorbar(im, label='Infidelity')
    plt.xlabel("ε (all equal)")
    plt.ylabel("θ₂")
    plt.title("Infidelity Heatmap vs θ₂ and ε (all eps equal)")
    plt.show()

# ----------------------------------------
# Example usage for 2D fidelities
# ----------------------------------------
def compute_n_z():
    #eps_range = (-np.pi, np.pi)
    eps_range = (-6e-3, 6e-3)
    E1, E2, _, Z = compute_grid(F_n_z, eps1_range=eps_range, eps2_range=eps_range)
    plot_heatmap(E1[:,:,0], E2[:,:,0], Z[:,:,0], title="$1-F_{n,z}$ Heatmap")
    plot_surface_3d(E1[:,:,0], E2[:,:,0], Z[:,:,0], title="$1-F_{n,z}$ Surface")

# F_x_z heatmap
def compute_x_z():
    eps_range = (-7e-3, 7e-3)
    E1, E2, _, Z = compute_grid(F_x_z, eps1_range=eps_range, eps2_range=eps_range)
    plot_heatmap(E1[:,:,0], E2[:,:,0], Z[:,:,0], title="$1-F_{x,z}$ Heatmap")
    plot_surface_3d(E1[:,:,0], E2[:,:,0], Z[:,:,0], title="$1-F_{x,z}$ Surface")

def compute_x_x():
    eps_range = (-5e-3, 5e-3)
    E1, E2, _, Z = compute_grid(F_x_x, eps1_range=eps_range, eps2_range=eps_range)
    plot_heatmap(E1[:,:,0], E2[:,:,0], Z[:,:,0], title="$1-F_{x,x}$ Heatmap")
    plot_surface_3d(E1[:,:,0], E2[:,:,0], Z[:,:,0], title="$1-F_{x,x}$ Surface")

def compute_z_n_z_fixed3():
    #Example usage for 3D fidelities (theta2-dependent)
    theta2 = np.arctan(np.sqrt(8))
    eps1_range = eps2_range = (-4.1e-3, 4.1e-3)
    eps3_fixed = 4.1e-3 #value used to validate formula
    eps1 = np.linspace(*eps1_range, 150)
    eps2 = np.linspace(*eps2_range, 150)
    E1, E2 = np.meshgrid(eps1, eps2)
    Z1 = F(theta2, E1, E2, eps3_fixed)
    plot_surface_3d(E1, E2, Z1,
                    xlabel="ε1",
                    ylabel="ε2",
                    title=f"Infidelity 1-F(theta2={theta2:.2f}, eps3={eps3_fixed:.3f})")

    plot_heatmap(E1, E2, Z1,
                xlabel="ε1",
                ylabel="ε2",
                title=f"Infidelity Heatmap 1-F(theta2={theta2:.2f}, eps3={eps3_fixed:.3f})")

def compute_z_n_z_fixed2():
    # tuning eps and fixing eps_2
    theta2 =np.arctan(np.sqrt(8))
    eps1_range = eps3_range = (-4.1e-3, 4.1e-3)
    eps2_fixed = 4.1e-3
    eps1 = np.linspace(*eps1_range, 150)
    eps3 = np.linspace(*eps3_range, 150)
    E1, E3 = np.meshgrid(eps1, eps3)
    Z2 = F(theta2, E1, eps2_fixed, E3)
    plot_surface_3d(E1, E3, Z2,
                    xlabel="ε1",
                    ylabel="ε3",
                    title=f"Infidelity 1-F(theta2={theta2:.2f}, eps2={eps2_fixed:.3f})")
    plot_heatmap(E1, E3, Z2,
                xlabel="ε1",
                ylabel="ε3",
                title=f"Infidelity Heatmap 1-F(theta2={theta2:.2f}, eps2={eps2_fixed:.3f})")


def compute_z_z_z_fixed3():
    eps1_range = eps2_range = (-3.33e-3, 3.33e-3)
    theta2 =np.arctan(np.sqrt(8)) #it is actually not relevant
    eps3_fixed = 3.33e-3 #value used to validate formula
    eps1 = np.linspace(*eps1_range, 150)
    eps2 = np.linspace(*eps2_range, 150)
    E1, E2 = np.meshgrid(eps1, eps2)
    Z3 = F_x_x_x( E1, E2, eps3_fixed)
    plot_surface_3d(E1, E2, Z3,
                    xlabel="ε1",
                    ylabel="ε2",
                    title=f"Infidelity 1-F(theta2={theta2:.2f}, eps3={eps3_fixed:.3f})")

    plot_heatmap(E1, E2, Z3,
                xlabel="ε1",
                ylabel="ε2",
                title=f"Infidelity Heatmap F(theta2={theta2:.2f}, eps3={eps3_fixed:.3f})")

def compute_different_theta():
    eps3_fixed= eps2_fixed= 4.1e-3
    eps1_range = eps2_range= eps3_range = (-np.pi*2, np.pi*2)
    eps1 = np.linspace(*eps1_range, 150)
    eps2 = -np.linspace(*eps2_range, 150)
    eps3 = np.linspace(*eps3_range, 150)
    E1, E2 = np.meshgrid(eps1, eps2)
    theta_list = [0, np.pi/4, np.pi/2, np.pi]
    #plot heatmaps for different theta and fixing epsilon 3
    plot_heatmaps_theta2(theta_list, E1, E2, eps3_fixed)
    # fixing epsilon 2
    E1, E3 = np.meshgrid(eps1, eps3)
    plot_heatmaps_theta2(theta_list, E1, eps2_fixed, E3, False, ylabel="ε3" )
    #let's fix all epsilon equal and compute the heatmap for epsilon and theta
    plot_heatmap_theta_vs_epsilon(theta_range=(-np.pi*2, np.pi*2), epsilon_range=(-4e-3, 4e-3))

def worst_case_f(theta2, err_bound):
    """Compute minimum F over eps1, eps2, eps3 in [-err_bound, err_bound]"""
    bounds = [(-err_bound, err_bound)] * 3

    def objective(x):
        e1, e2, e3 = x
        return F(theta2, e1, e2, e3)

    res = differential_evolution(objective, bounds, tol=1e-9)
    return res.fun, res.x  # (min fidelity, argmin parameters)


def find_minimal_error_threshold(theta2, target_infidelity=1e-4, e_max=0.5):
    """
    Find the smallest error amplitude e for which the condition
        1 - F_min(e) > target_infidelity
    is exceeded.

    Returns:
        e_star: minimal error amplitude
        F_min: worst-case fidelity at e_star
        params: eps1, eps2, eps3 that produce F_min
    """

    # increasing e search (binary search for speed)
    low, high = 0.0, e_max

    for _ in range(30):  # ~1e-6 precision on e
        mid = 0.5 * (low + high)

        F_min, params = worst_case_f(theta2, mid)

        if 1 - F_min > target_infidelity:
            high = mid  # too much error → reduce search interval
        else:
            low = mid   # still acceptable → need bigger errors

    return high, F_min, params

def main():
    # #xz rotation
    # compute_x_z()

    # #nz rotation        
    # compute_n_z()

    # ##zz rotation
    # compute_x_x() #xx same as zz
    # plt.show()

    # #znz rotation
    # compute_z_n_z_fixed2() #fixing epsilon 2
    # compute_z_n_z_fixed3() #fixing epsilon 3

    # #zzz rotation
    # compute_z_z_z_fixed3() #centered where the argument of cos is 0
    # plt.show()

    # understand evoution with theta
    compute_different_theta()
    plt.show()

main()

#theta2 = np.arctan(np.sqrt(8)) # example
theta2 =np.pi

e_star, F_min_star, params_star = find_minimal_error_threshold(theta2)

print("Minimal e* =", e_star)
print("At this error, worst-case F =", F_min_star)
print("So 1 - F =", 1 - F_min_star)
print("Error values producing failure:", params_star)