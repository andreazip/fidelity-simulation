import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.optimize import differential_evolution

# Pauli matrices
I = np.eye(2)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)

def R(pauli, theta):
    return np.cos(theta/2)*I - 1j*np.sin(theta/2)*pauli

def fidelity(Ut, U):
    return 0.25 * (abs(np.trace(Ut.conj().T @ U)))**2

def compute_2pulses(U1, U2, e1_vals, e2_vals, theta1, theta2):
    F = np.zeros((len(e1_vals), len(e2_vals)))

    for i, e1 in enumerate(e1_vals):
        for j, e2 in enumerate(e2_vals):
            U = R(U1, theta1 + 2*e1) @ R(U2, theta2 + 2*e2)
            Ut = R(U1, theta1) @ R(U2, theta2)
            F[i, j] = fidelity(Ut, U)

    return F


def compute_3pulses(U1, U2, U3, e1_vals, e2_scalar, e3_vals, theta1, theta2, theta3):
    F = np.zeros((len(e1_vals), len(e3_vals)))

    for i, e1 in enumerate(e1_vals):
        for j, e3 in enumerate(e3_vals):
            U = ( R(U1, theta1 + 2*e1)
                @ R(U2, theta2 + 2*e2_scalar)
                @ R(U3, theta3 + 2*e3) )
            Ut = R(U1, theta1) @ R(U2, theta2) @ R(U3, theta3)
            F[i, j] = fidelity(Ut, U)

    return F

def plot_heatmap(F,xlabel="ε1", ylabel="ε2", title="Infidelity Heatmap"):
    F = F.copy()
    # Compute infidelity
    inf = 1 - F
    # Find smallest positive infidelity
    nz_min = np.min(inf[inf > 0])
    # Replace zeros in INFIDELITY
    inf[inf == 0] = nz_min
    plt.figure(figsize=(6,5))
    plt.imshow(np.log10(inf), origin='lower', extent=[errs[0], errs[-1], errs[0], errs[-1]],
            cmap='viridis',  aspect='auto')
    plt.colorbar(label='Infidelity')
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title)
    #plt.show()

def find_minimal_eps_2pulse_opt(U1, U2, theta1, theta2,
                                threshold=1e-4, e_max=0.02):

    # Objective with penalty
    def objective(params):
        eps1, eps2 = params

        # Compute infidelity
        U = R(U1, theta1 + 2*eps1) @ R(U2, theta2 + 2*eps2)
        Ut = R(U1, theta1) @ R(U2, theta2)
        inf = 1 - fidelity(Ut, U)

        r = np.sqrt(eps1**2 + eps2**2)

        # Penalty if violation NOT reached
        if inf < threshold:
            penalty = 1e3 * (threshold - inf)
        else:
            penalty = 0.0

        return r + penalty

    bounds = [(-e_max, e_max), (-e_max, e_max)]

    result = differential_evolution(
        objective,
        bounds,
        tol=1e-9,
        maxiter=2000,
        polish=True
    )

    eps1_opt, eps2_opt = result.x

    # Compute actual fidelity at solution
    U = R(U1, theta1 + 2*eps1_opt) @ R(U2, theta2 + 2*eps2_opt)
    Ut = R(U1, theta1) @ R(U2, theta2)
    inf = 1 - fidelity(Ut, U)

    return {
        "eps1": eps1_opt,
        "eps2": eps2_opt,
        "r": np.sqrt(eps1_opt**2 + eps2_opt**2),
        "infidelity": inf
    }

def find_minimal_eps_3pulse_opt(U1, U2, U3, theta1, theta2, theta3,
                                threshold=1e-4, e_max=0.02):
    """
    Finds the minimal |eps1|, |eps2|, |eps3| such that the 3-pulse sequence
    exceeds the infidelity threshold.
    """

    def objective(params):
        eps1, eps2, eps3 = params

        # Compute infidelity
        U = (R(U1, theta1 + 2*eps1) 
             @ R(U2, theta2 + 2*eps2) 
             @ R(U3, theta3 + 2*eps3))
        Ut = R(U1, theta1) @ R(U2, theta2) @ R(U3, theta3)
        inf = 1 - fidelity(Ut, U)

        r = np.sqrt(eps1**2 + eps2**2 + eps3**2)

        # Penalty if infidelity threshold not reached
        if inf < threshold:
            penalty = 1e3 * (threshold - inf)
        else:
            penalty = 0.0

        return r + penalty

    bounds = [(-e_max, e_max), (-e_max, e_max), (-e_max, e_max)]

    result = differential_evolution(
        objective,
        bounds,
        tol=1e-9,
        maxiter=3000,
        polish=True
    )

    eps1_opt, eps2_opt, eps3_opt = result.x

    # Compute actual fidelity at solution
    U = (R(U1, theta1 + 2*eps1_opt) 
         @ R(U2, theta2 + 2*eps2_opt) 
         @ R(U3, theta3 + 2*eps3_opt))
    Ut = R(U1, theta1) @ R(U2, theta2) @ R(U3, theta3)
    inf = 1 - fidelity(Ut, U)

    return {
        "eps1": eps1_opt,
        "eps2": eps2_opt,
        "eps3": eps3_opt,
        "r": np.sqrt(eps1_opt**2 + eps2_opt**2 + eps3_opt**2),
        "infidelity": inf
    }

# Target angles
theta1 = np.pi-np.arctan(np.sqrt(8))  # X rotation
#theta2 = np.arctan(np.sqrt(8))  # n rotation
theta2 = 0  # n rotation
n = -(np.sqrt(3)*X+ Z)/2 # this should be with a minus


errs = np.linspace(-0.007, 0.007, 150) 
#xz rotation
F_xz = compute_2pulses(Z,X,errs, errs, theta1, theta2)
plot_heatmap(F_xz, title="Infidelity heatmap x,z rotation")

errs = np.linspace(-0.006, 0.006, 150) 
#nz rotation
F_nz = compute_2pulses(n,Z,errs, errs, theta1, theta2)
plot_heatmap(F_nz, title="Infidelity heatmap n,z rotation")

# Error ranges
errs = np.linspace(-0.005, 0.005, 150)  
#xx rotation
F_xx = compute_2pulses(X,X,errs, errs, theta1, theta2)
plot_heatmap(F_xx,title="Infidelity heatmap x,x rotation")


#errs = np.linspace(-0.0041, 0.0041, 150) 
errs = np.linspace(-np.pi, np.pi, 150) 
#znz rotation
F_znz = compute_3pulses(Z,n,Z,errs, 4.1e-3, errs, theta1, theta2, theta1)
plot_heatmap(F_znz, title="Infidelity heatmap z,n,z rotation")

errs = np.linspace(-0.0034, 0.0034, 150)  
#zzz rotation
F_znz = compute_3pulses(Z,Z,Z,errs, -3.4e-3, errs, theta1, theta2, theta1)
plot_heatmap(F_znz, title="Infidelity heatmap z,z,z rotation")

res = find_minimal_eps_2pulse_opt(Z, X, theta1, theta2)
print(res)

res_znz = find_minimal_eps_3pulse_opt(Z, X, Z, theta1, theta2, theta1)
print(res_znz)

plt.show()