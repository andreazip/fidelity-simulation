import numpy as np
import matplotlib.pyplot as plt

# ----------------------------------------
# Define F(theta2, eps1, eps2, eps3)
# ----------------------------------------

def fidelity_two_rotations(epsilon1, epsilon2):
    """
    Compute the fidelity-like function for two rotations around z and n axis.
    
    Parameters
    ----------
    epsilon1 : float
        Rotation angle error around z-axis (radians)
    epsilon2 : float
        Rotation angle error around axis n (radians)
    
    Returns
    -------
    float
        Fidelity
    """
    return (np.cos(epsilon2) * np.cos(epsilon1) - 0.5 * np.sin(epsilon2) * np.sin(epsilon1))**2

def fidelity_two_rotations_simple(epsilon1, epsilon2):
    """
    Compute fidelity for two rotations around z and x axis 
    F = [cos(epsilon2) * cos(epsilon1)]^2
    
    Parameters
    ----------
    epsilon1 : float
        Rotation angle error around z-axis (radians)
    epsilon2 : float
        Rotation angle error around x-axis (radians)
    
    Returns
    -------
    float
        Fidelity
    """
    return (np.cos(epsilon1) * np.cos(epsilon2))**2
    
def fidelity_general(theta2, epsilon1, epsilon2):
    """
    Compute the fidelity function for two rotations with errors.
    
    Parameters
    ----------
    theta2 : float
        Rotation angle of the main pulse (radians)
    epsilon1 : float
        Error rotation 1 (radians)
    epsilon2 : float
        Error rotation 2 (radians)
    
    Returns
    -------
    float
        Fidelity
    """
    delta_epsilon = epsilon2 - epsilon1
    epsilon_tot = epsilon2 + epsilon1
    
    term1 = (3/4) * np.sin(theta2/2) * np.sin(theta2/2 + epsilon2) * np.cos(delta_epsilon)
    term2 = (np.cos(theta2/2) * np.cos(theta2/2 + epsilon2) + (1/4) * np.sin(theta2/2) * np.sin(theta2/2 + epsilon2)) * np.cos(epsilon_tot)
    term3 = -0.5 * np.sin(epsilon2) * np.sin(epsilon_tot)
    
    F = (term1 + term2 + term3)**2
    return F

# ----------------------------------------
# Simple fidelity: cos^2(eps1)cos^2(eps2)cos^2(eps3)
# ----------------------------------------
def F_simple(eps1, eps2, eps3):
    return (np.cos(eps1)**2) * (np.cos(eps2)**2) * (np.cos(eps3)**2)

# ----------------------------------------
# 3D surface plot: Z = F(theta2, eps1, eps2, eps3)
# ----------------------------------------
def plot_F(theta2, eps2, eps1_range, eps3_range, resolution=200):
    eps1 = np.linspace(*eps1_range, resolution)
    eps3 = np.linspace(*eps3_range, resolution)
    E1, E3 = np.meshgrid(eps1, eps3)

    Z = 1-F(theta2, E1, eps2, E3)

    fig = plt.figure(figsize=(9,6))
    ax = fig.add_subplot(111, projection='3d')

    ax.plot_surface(E1, E3, np.log10(Z))

    ax.set_xlabel("ε₁")
    ax.set_ylabel("ε₃")
    ax.set_zlabel("F")

    plt.title(f"F(θ₂={theta2}, ε₂={eps2})")
    plt.show()

def find_max_F(theta2, eps2, eps1_range, eps3_range, resolution=400):
    eps1 = np.linspace(*eps1_range, resolution)
    eps3 = np.linspace(*eps3_range, resolution)
    E1, E3 = np.meshgrid(eps1, eps3)

    Z = F(theta2, E1, eps2, E3)

    max_val = np.max(Z)
    idx = np.argmax(Z)

    # unravel index to get coordinates
    i, j = np.unravel_index(idx, Z.shape)
    eps1_max = E1[i, j]
    eps3_max = E3[i, j]
    return max_val, eps1_max, eps3_max

# ----------------------------------------
# Plot both fidelities on the same figure
# ----------------------------------------
def plot_both(theta2, eps2, eps1_range, eps3_range, resolution=150):

    # Create grid
    eps1 = np.linspace(*eps1_range, resolution)
    eps3 = np.linspace(*eps3_range, resolution)
    E1, E3 = np.meshgrid(eps1, eps3)

    # Evaluate both fidelities
    Z_full = 1-F(theta2, E1, eps2, E3)
    Z_simple = 1-F_simple(E1, eps2, E3)

    # Plot
    fig = plt.figure(figsize=(10,7))
    ax = fig.add_subplot(111, projection='3d')

    ax.plot_surface(E1, E3, np.log10(Z_full), alpha=0.6)
    ax.plot_surface(E1, E3, np.log10(Z_simple), alpha=0.6)

    ax.set_xlabel("ε₁")
    ax.set_ylabel("ε₃")
    ax.set_zlabel("Fidelities")
    plt.title("Full Fidelity vs Simple Fidelity")

    plt.show()

# ----------------------------------------
# Heatmap plotting
# ----------------------------------------
def plot_heatmaps(theta2, eps2, eps1_range, eps3_range, resolution=300):

    # Create grid
    eps1 = np.linspace(*eps1_range, resolution)
    eps3 = np.linspace(*eps3_range, resolution)
    E1, E3 = np.meshgrid(eps1, eps3)

    # Compute values
    Z_full = 1-F(theta2, E1, eps2, E3)
    Z_simple = 1-F_simple(E1, eps2, E3)

    # Plot side-by-side heatmaps
    fig, ax = plt.subplots(1, 2, figsize=(14, 5))

    im1 = ax[0].imshow(np.log10(Z_full), extent=[*eps1_range, *eps3_range],
                       origin='lower', cmap='viridis', aspect='auto')
    ax[0].set_title("Full Fidelity Heatmap")
    ax[0].set_xlabel("ε₁")
    ax[0].set_ylabel("ε₃")
    fig.colorbar(im1, ax=ax[0])

    im2 = ax[1].imshow(np.log10(Z_simple), extent=[*eps1_range, *eps3_range],
                       origin='lower', cmap='viridis', aspect='auto')
    ax[1].set_title("Simple Fidelity Heatmap")
    ax[1].set_xlabel("ε₁")
    ax[1].set_ylabel("ε₃")
    fig.colorbar(im2, ax=ax[1])

    plt.tight_layout()
    plt.show()

# ----------------------------------------
# Example usage
# ----------------------------------------
theta2_value = 0.3     # choose your θ₂
eps2_value = 0.1       # choose your ε₂

plot_heatmaps(
    theta2_value,
    eps2_value,
    eps1_range=(-0.5, 0.5),
    eps3_range=(-0.5, 0.5),
    resolution=300
)

plot_both(
    theta2_value,
    eps2_value,
    eps1_range=(-0.5, 0.5),
    eps3_range=(-0.5, 0.5),
    resolution=150
)

plot_F(
    theta2=theta2_value,
    eps2=eps2_value,
    eps1_range=(-np.pi, np.pi),
    eps3_range=(-np.pi, np.pi),
    resolution=200
)